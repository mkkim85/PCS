#include "header.h"

double REPORT_KW, REPORT_TOTAL_KW;
double REPORT_KW_NPG, REPORT_TOTAL_KW_NPG; // non-primary groups
double REPORT_RESP_T_TOTAL, REPORT_Q_DELAY_T_TOTAL;
long REPORT_RESP_T_COUNT, REPORT_Q_DELAY_T_COUNT;
long REPORT_LOCALITY[LOCAL_LENGTH];
long REPORT_RACK_STATE_COUNT[STATE_LENGTH], REPORT_NODE_STATE_COUNT[STATE_LENGTH];
long REPORT_MAP_TASKS;

extern bool CSIM_END;
extern long SETUP_REPORT_PERIOD;
extern FILE *SETUP_REPORT_PATH;
extern node_map_t ACTIVE_NODE_SET, STANDBY_NODE_SET;
extern rack_map_t ACTIVE_RACK_SET, STANDBY_RACK_SET;

void sim_report(void)
{
	long t;
	long hold_t = SETUP_REPORT_PERIOD;

	fprintf(SETUP_REPORT_PATH, "clock,kW,total_kW,kW_npg,total_kW_npg,node,rack,total_resp_t,resp_t_count,avg_resp_t,total_q_delay_t,q_delay_count,avg_q_delay,local_node,local_rack,local_remote,map_tasks\n");

	create("report");
	while (!CSIM_END)
	{
		t = clock;

		REPORT_KW = REPORT_KW
			+ (REPORT_RACK_STATE_COUNT[STATE_ACTIVE] * (RACK_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_STANDBY] * (NODE_S_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_ACTIVATE] * (NODE_U_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_DEACTIVATE] * (NODE_D_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_ACTIVE] * (NODE_A_POWER / HOUR));

		REPORT_KW_NPG = REPORT_KW_NPG
			+ ((REPORT_RACK_STATE_COUNT[STATE_ACTIVE] - CS_RACK_NUM) * (RACK_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_STANDBY] * (NODE_S_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_ACTIVATE] * (NODE_U_POWER / HOUR))
			+ (REPORT_NODE_STATE_COUNT[STATE_DEACTIVATE] * (NODE_D_POWER / HOUR))
			+ ((REPORT_NODE_STATE_COUNT[STATE_ACTIVE] - CS_NODE_NUM) * (NODE_A_POWER / HOUR));

		REPORT_KW /= 1000.0;
		REPORT_KW_NPG /= 1000.0;

		if (t > 0 && (t % hold_t) == 0)
		{
			REPORT_TOTAL_KW += REPORT_KW;
			REPORT_TOTAL_KW_NPG += REPORT_KW_NPG;

			fprintf(SETUP_REPORT_PATH, "%ld,%lf,%lf,%lf,%lf,%ld,%ld,%lf,%ld,%lf,%lf,%ld,%lf,%ld,%ld,%ld,%ld\n",
				(long)clock, REPORT_KW, REPORT_TOTAL_KW, 
				REPORT_KW_NPG, REPORT_TOTAL_KW_NPG,
				ACTIVE_NODE_SET.size(), ACTIVE_RACK_SET.size(),
				REPORT_RESP_T_TOTAL, REPORT_RESP_T_COUNT, (REPORT_RESP_T_TOTAL / REPORT_RESP_T_COUNT),
				REPORT_Q_DELAY_T_TOTAL, REPORT_Q_DELAY_T_COUNT, (REPORT_Q_DELAY_T_TOTAL / REPORT_Q_DELAY_T_COUNT),
				REPORT_LOCALITY[LOCAL_NODE], REPORT_LOCALITY[LOCAL_RACK], REPORT_LOCALITY[LOCAL_REMOTE],
				REPORT_MAP_TASKS);

			REPORT_KW = 0;
			REPORT_KW_NPG = 0;

			REPORT_RESP_T_TOTAL = 0;
			REPORT_RESP_T_COUNT = 0;

			REPORT_Q_DELAY_T_TOTAL = 0;
			REPORT_Q_DELAY_T_COUNT = 0;

			for (long i = 0; i < LOCAL_LENGTH; ++i)
			{
				REPORT_LOCALITY[i] = 0;
			}

			REPORT_MAP_TASKS = 0;
		}

		hold(TIME_UNIT);
	}
}